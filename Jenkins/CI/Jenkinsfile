#!/usr/bin/env groovy
@Library(['eng-build-utils']) _

pipeline {
    agent { 
        node {
            label "${env.NODE_LABELS}"
        }
    }
    environment {
        GRADLE_HOME = tool name: 'Gradle-Kayako', type: 'gradle'
    }
    options {
        timestamps()
    }
    stages {
        stage('Environment') {
            steps {
                sh 'printenv'
                sh 'gradle --version'
            }
        }
        stage('Build') {
            steps {
                dir("ProjectSource") {
                    // devfactory (
                    //     portfolio: 'TestPFAurea',
                    //     product: 'Firstrain',
                    //     productVersion: "${env.ALINE_PRODUCT_VERSION}",
                    //     types: 'Java',
                    //     scmRelativeDir: '../',
                    //     processTests: false
                    // ) {
                        sh "gradle test"
                    // }
                }
                dir("ProjectSource") {
                    script {
                        def files = findFiles(glob: '**/build/test-results/TEST-*.xml')
                        if (files) {
                            junit '**/build/test-results/TEST-*.xml'
                        }
                    }
                }
            }
        }
        stage("Jacoco")
        {   
            when { expression { return params.CHECK_COVERAGE } }
            steps {
                script {
                    files = findFiles(glob: "**/*.exec")
                    if (files) {
                        jacoco (
                            exclusionPattern: '**/*Test*.class',
                            buildOverBuild: true,
                            deltaClassCoverage: "${env.DELTA_CLASS_COVERAGE}",
                            deltaLineCoverage: "${env.DELTA_LINE_COVERAGE}",
                            deltaMethodCoverage: "${env.DELTA_METHOD_COVERAGE}",
                            deltaInstructionCoverage: "${env.DELTA_INSTRUCTION_COVERAGE}",
                            deltaBranchCoverage: "${env.DELTA_BRANCH_COVERAGE}",
                            deltaComplexityCoverage: "${env.DELTA_COMPLEXITY_COVERAGE}"
                        )
                    }
                }
            } 
        }   
    }
    post {
        always {
            script {
                sh("echo 'CURRENT BUILD RESULT: ${currentBuild.currentResult}'")
                sh("echo 'CURRENT GITHUB URL: ${env.GIT_URL}'")
                sh("echo 'CURRENT GITHUB COMMIT: ${env.GIT_COMMIT}'")

                // it shoud give us previous commit, we'll set github status on, to get correct check result
                def previousCommit = sh (script: "git show HEAD | grep Merge |  tail -1 | awk '{print \$2}'", returnStdout: true).trim()
                sh("echo 'PREVIOUS GITHUB COMMIT: ${previousCommit}'")

                def commitToSetStatusOn = "${env.GIT_COMMIT}"
                if ("${env.GITHUB_CONTEXT}" == "jenkins-pr/build-result" ) {
                    commitToSetStatusOn = previousCommit
                }

                def githubCommit = new com.aurea.setGitHubCommitStatus()
                githubCommit.setGitHubCommitStatus("Build ${env.BUILD_VERSION}", "${currentBuild.currentResult}", "${env.GIT_URL}", "${commitToSetStatusOn}", "${env.GITHUB_CONTEXT}")
            }
            script {
                def comitterEmail = sh (
                    script: "git rev-parse HEAD | git show --format='%ae' | grep -m1 ''",
                    returnStdout: true
                ).trim()
                
                step([$class: 'Mailer',
                    recipients: "${comitterEmail},${env.EMAIL_TO}",
                    notifyEveryUnstableBuild: true
                ])
            }            
        }
    }
}
